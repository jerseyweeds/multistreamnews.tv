<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Live Feed Scanner - MultiStreamNews.TV</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
            min-height: 100vh;
        }
        
        .scanner-container {
            background: rgba(31, 41, 55, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(75, 85, 99, 0.3);
        }
        
        .feed-row:hover {
            background-color: rgba(59, 130, 246, 0.1);
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-live {
            background-color: #ef4444;
            animation: pulse 2s infinite;
        }
        
        .status-upcoming {
            background-color: #f59e0b;
        }
        
        .status-offline {
            background-color: #6b7280;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .loading-spinner {
            border: 3px solid #374151;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .copy-button {
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .feed-row:hover .copy-button {
            opacity: 1;
        }
    </style>
</head>
<body class="text-white">
    <div class="min-h-screen p-4 md:p-8">
        <div class="max-w-7xl mx-auto">
            <!-- Header -->
            <div class="text-center mb-8">
                <h1 class="text-3xl md:text-4xl font-bold text-white mb-2">Dynamic Live News Scanner</h1>
                <p class="text-gray-300">Discover and analyze live YouTube news streams with comprehensive metadata extraction</p>
                <a href="index.html" class="inline-block mt-4 text-blue-400 hover:text-blue-300 transition-colors">
                    ‚Üê Back to MultiStreamNews.TV
                </a>
            </div>

            <!-- Scanner Controls -->
            <div class="scanner-container rounded-lg p-6 mb-8">
                <h2 class="text-xl font-semibold mb-4">News Stream Scanner</h2>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-300 mb-2">
                            Scan Mode:
                        </label>
                        <select 
                            id="scanMode" 
                            class="w-full p-3 bg-gray-700 border border-gray-600 rounded-md text-white focus:ring-blue-500 focus:border-blue-500"
                        >
                            <option value="dynamic">News (General)</option>
                            <option value="breaking">Breaking News</option>
                            <option value="business">Business News</option>
                            <option value="live">Live News</option>
                            <option value="custom">Custom YouTube URL</option>
                        </select>
                    </div>
                    
                    <div>
                        <label class="block text-sm font-medium text-gray-300 mb-2">
                            Scan Options:
                        </label>
                        <div class="flex gap-2">
                            <label class="flex items-center">
                                <input type="checkbox" id="includeDuration" checked class="mr-2 rounded bg-gray-700 border-gray-600">
                                <span class="text-sm">Include Duration</span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- Custom URL Input (hidden by default) -->
                <div id="customUrlContainer" class="mb-4 hidden">
                    <label class="block text-sm font-medium text-gray-300 mb-2">
                        Custom YouTube URL:
                    </label>
                    <input 
                        type="text" 
                        id="customUrl" 
                        placeholder="https://www.youtube.com/results?search_query=your+search&sp=CAASBBABQAE%253D"
                        class="w-full p-3 bg-gray-700 border border-gray-600 rounded-md text-white focus:ring-blue-500 focus:border-blue-500"
                    >
                    <div class="text-xs text-gray-400 mt-1">
                        Enter a YouTube search URL with live stream filter. Use &sp=CAASBBABQAE%253D for live streams.
                    </div>
                </div>
                
                <!-- Real-time scan progress -->
                <div id="scanProgress" class="mb-4 hidden">
                    <div class="bg-gray-800 rounded-lg p-4">
                        <div class="text-sm font-medium text-gray-300 mb-2">Scan Progress:</div>
                        <div id="currentScanUrl" class="text-xs text-blue-400 mb-2 break-all"></div>
                        <div id="foundStreams" class="space-y-1 max-h-32 overflow-y-auto"></div>
                    </div>
                </div>
                
                <div class="flex flex-wrap gap-3">
                    <button 
                        id="scanButton" 
                        class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg transition-colors duration-300 flex items-center"
                    >
                        <span id="scanButtonText">Scan News Feeds</span>
                        <div id="scanLoader" class="loading-spinner ml-2 hidden"></div>
                    </button>
                    
                    <button 
                        id="clearButton" 
                        class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded-lg transition-colors duration-300"
                    >
                        Clear Results
                    </button>
                    
                    <button 
                        id="exportButton" 
                        class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg transition-colors duration-300"
                        disabled
                    >
                        Export CSV
                    </button>
                    
                    <button 
                        id="copyUrlsButton" 
                        class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-6 rounded-lg transition-colors duration-300"
                        disabled
                    >
                        Copy URLs
                    </button>
                </div>
            </div>

            <!-- Status Messages -->
            <div id="statusMessage" class="hidden mb-6 p-4 rounded-lg"></div>

            <!-- Results Table -->
            <div id="resultsContainer" class="hidden scanner-container rounded-lg p-6">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-semibold">Live Feeds Found</h2>
                    <span id="feedCount" class="text-gray-400">0 feeds</span>
                </div>
                
                <div class="overflow-x-auto">
                    <table class="w-full table-auto">
                        <thead>
                            <tr class="border-b border-gray-600">
                                <th class="text-left py-3 px-2 font-medium text-gray-300">Status</th>
                                <th class="text-left py-3 px-2 font-medium text-gray-300">Network</th>
                                <th class="text-left py-3 px-2 font-medium text-gray-300">Title</th>
                                <th class="text-left py-3 px-2 font-medium text-gray-300">Channel</th>
                                <th class="text-left py-3 px-2 font-medium text-gray-300">Duration</th>
                                <th class="text-left py-3 px-2 font-medium text-gray-300">Discovery</th>
                                <th class="text-left py-3 px-2 font-medium text-gray-300">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="feedsTableBody">
                            <!-- Dynamic content will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Technical Notes -->
            <div class="scanner-container rounded-lg p-6 mt-8">
                <h3 class="text-lg font-semibold mb-3">Real YouTube Stream Scanner - CORS Limited</h3>
                <div class="text-sm text-gray-300 space-y-2">
                    <p><strong>‚ö†Ô∏è CORS Limitation:</strong> Browser security prevents direct YouTube page fetching. Results may be empty due to CORS policy.</p>
                    <p><strong>üîß Current Mode:</strong> Attempting real YouTube search page fetching with CORS error handling.</p>
                    <p><strong>üìã Categories:</strong> General News, Breaking News, Business News, Live News, and Custom URL support.</p>
                    <p><strong>üéØ Stream Limit:</strong> Displays up to 50 streams per scan from actual YouTube search results.</p>
                    <p><strong>üîç Custom URLs:</strong> Enter your own YouTube search URLs with live stream filters.</p>
                    <p><strong>üìä Real-time Progress:</strong> Shows URL being scanned and found streams as they are discovered.</p>
                    <p><strong>‚úÖ Working Features:</strong> YouTube oEmbed API for metadata, CSV export, URL copying, and real-time scan progress.</p>
                    <p><strong>üöÄ Production Solution:</strong> Requires backend proxy server, browser extension, or YouTube Data API v3 to bypass CORS.</p>
                </div>
                
                <div class="mt-4 p-4 bg-red-900/30 rounded border border-red-700">
                    <h4 class="font-semibold text-red-300 mb-2">CORS Error Expected</h4>
                    <div class="text-xs text-red-200 space-y-1">
                        <p>‚Ä¢ Browser will block YouTube requests due to CORS policy</p>
                        <p>‚Ä¢ No sample data - only real YouTube results (if accessible)</p>
                        <p>‚Ä¢ Error messages will appear in real-time progress display</p>
                        <p>‚Ä¢ Check browser console for detailed CORS error logs</p>
                        <p>‚Ä¢ For production: implement backend proxy or use YouTube Data API</p>
                        <p>‚Ä¢ Alternative: use browser extension to disable CORS temporarily</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class NewsStreamScanner {
            constructor() {
                this.feeds = [];
                this.isScanning = false;
                this.initializeEventListeners();
                this.initializeNewsStreams();
            }

            initializeNewsStreams() {
                // Authoritative YouTube search URLs for live feed discovery
                this.liveStreamSources = [
                    {
                        name: 'News',
                        url: 'https://www.youtube.com/results?search_query=news&sp=CAASBBABQAE%253D',
                        category: 'news'
                    },
                    {
                        name: 'Breaking News',
                        url: 'https://www.youtube.com/results?search_query=breaking+news&sp=CAASBBABQAE%253D',
                        category: 'breaking'
                    },
                    {
                        name: 'Business News',
                        url: 'https://www.youtube.com/results?search_query=business+news&sp=CAASBBABQAE%253D',
                        category: 'business'
                    },
                    {
                        name: 'Live News',
                        url: 'https://www.youtube.com/results?search_query=live+news&sp=CAASBBABQAE%253D',
                        category: 'live'
                    }
                ];
            }

            initializeEventListeners() {
                document.getElementById('scanButton').addEventListener('click', () => this.scanFeeds());
                document.getElementById('clearButton').addEventListener('click', () => this.clearResults());
                document.getElementById('exportButton').addEventListener('click', () => this.exportResults());
                document.getElementById('copyUrlsButton').addEventListener('click', () => this.copyUrls());
                
                // Handle scan mode changes to show/hide custom URL input
                document.getElementById('scanMode').addEventListener('change', (e) => {
                    const customUrlContainer = document.getElementById('customUrlContainer');
                    if (e.target.value === 'custom') {
                        customUrlContainer.classList.remove('hidden');
                    } else {
                        customUrlContainer.classList.add('hidden');
                    }
                });
            }

            async getStreamsToScan() {
                const scanMode = document.getElementById('scanMode').value;
                
                try {
                    switch (scanMode) {
                        case 'dynamic':
                            return await this.discoverLiveStreams(this.liveStreamSources[0].url, this.liveStreamSources[0].category);
                        case 'breaking':
                            return await this.discoverLiveStreams(this.liveStreamSources[1].url, this.liveStreamSources[1].category);
                        case 'business':
                            return await this.discoverLiveStreams(this.liveStreamSources[2].url, this.liveStreamSources[2].category);
                        case 'live':
                            return await this.discoverLiveStreams(this.liveStreamSources[3].url, this.liveStreamSources[3].category);
                        case 'custom':
                            const customUrl = document.getElementById('customUrl').value.trim();
                            if (!customUrl) {
                                this.showStatus('Please enter a custom YouTube URL', 'error');
                                return [];
                            }
                            if (!customUrl.includes('youtube.com')) {
                                this.showStatus('Please enter a valid YouTube URL', 'error');
                                return [];
                            }
                            return await this.discoverLiveStreams(customUrl, 'custom');
                        default:
                            return await this.discoverLiveStreams(this.liveStreamSources[0].url, this.liveStreamSources[0].category);
                    }
                } catch (error) {
                    console.error('Stream discovery failed:', error);
                    this.showStatus('Failed to discover streams from YouTube', 'error');
                    return [];
                }
            }

            async discoverLiveStreams(sourceUrl, category) {
                // Show scan progress container
                const progressContainer = document.getElementById('scanProgress');
                const currentScanUrl = document.getElementById('currentScanUrl');
                const foundStreams = document.getElementById('foundStreams');
                
                progressContainer.classList.remove('hidden');
                currentScanUrl.textContent = `Scanning: ${sourceUrl}`;
                foundStreams.innerHTML = '';
                
                this.showStatus('Attempting to fetch YouTube search results...', 'info');
                
                try {
                    console.log(`Fetching: ${sourceUrl} for category: ${category}`);
                    
                    // Try to fetch the YouTube search page directly
                    const response = await fetch(sourceUrl, {
                        method: 'GET',
                        headers: {
                            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                        },
                        mode: 'cors'
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const html = await response.text();
                    console.log(`Successfully fetched ${html.length} characters from YouTube`);
                    
                    // Extract live streams from the HTML
                    const discoveredStreams = this.extractLiveStreamsFromHTML(html, category);
                    
                    // Show discovered streams in real time
                    for (const stream of discoveredStreams) {
                        // Add a small delay to show progress
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                        // Show the found stream URL in real time
                        const streamDiv = document.createElement('div');
                        streamDiv.className = 'text-xs text-green-400 py-1';
                        streamDiv.innerHTML = `
                            <span class="text-gray-400">Found:</span> 
                            <span class="text-blue-400">${stream.url}</span> 
                            <span class="text-gray-300">(${stream.title})</span>
                        `;
                        foundStreams.appendChild(streamDiv);
                        foundStreams.scrollTop = foundStreams.scrollHeight;
                        
                        // Update progress status
                        currentScanUrl.textContent = `Scanning: ${sourceUrl} - Found ${discoveredStreams.length} streams`;
                    }
                    
                    if (discoveredStreams.length === 0) {
                        this.showStatus('No live streams found in YouTube search results', 'warning');
                        return [];
                    }
                    
                    this.showStatus(`Found ${discoveredStreams.length} live streams from YouTube search`, 'success');
                    return discoveredStreams;
                    
                } catch (error) {
                    console.error('Error fetching YouTube page:', error);
                    
                    // Show CORS error message
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'text-xs text-red-400 py-2 border-t border-gray-600';
                    errorDiv.innerHTML = `
                        <span class="text-red-400">‚ùå CORS Error:</span> ${error.message}<br>
                        <span class="text-gray-400">Browser blocked the request to YouTube. This requires a backend service or browser extension to bypass CORS restrictions.</span>
                    `;
                    foundStreams.appendChild(errorDiv);
                    
                    this.showStatus(`CORS Error: Cannot fetch YouTube directly from browser. ${error.message}`, 'error');
                    return [];
                }
            }

            extractLiveStreamsFromHTML(html, category) {
                const streams = [];
                
                try {
                    // Primary Pattern: Look for the specific live badge marker first
                    const liveBadgePatterns = [
                        /badge-style-type-live-now-alternate.*?href="\/watch\?v=([a-zA-Z0-9_-]{11})"/gi,
                        /href="\/watch\?v=([a-zA-Z0-9_-]{11})".*?badge-style-type-live-now-alternate/gi,
                        /"videoId":"([a-zA-Z0-9_-]{11})".*?badge-style-type-live-now-alternate/gi,
                        /badge-style-type-live-now-alternate.*?"videoId":"([a-zA-Z0-9_-]{11})"/gi
                    ];
                    
                    const confirmedLiveStreams = new Set();
                    
                    // Try each badge pattern
                    for (const pattern of liveBadgePatterns) {
                        let match;
                        while ((match = pattern.exec(html)) !== null) {
                            const videoId = match[1];
                            if (videoId) {
                                confirmedLiveStreams.add(videoId);
                                console.log(`Found live stream with badge: ${videoId}`);
                            }
                        }
                    }
                    
                    // Alternative live badge pattern (look around the video ID)
                    const videoIdPattern = /"videoId":"([a-zA-Z0-9_-]{11})"/g;
                    let videoMatch;
                    while ((videoMatch = videoIdPattern.exec(html)) !== null) {
                        const videoId = videoMatch[1];
                        const videoIdIndex = videoMatch.index;
                        
                        // Check for live badge within 2000 characters around the video ID
                        const contextStart = Math.max(0, videoIdIndex - 1000);
                        const contextEnd = Math.min(html.length, videoIdIndex + 1000);
                        const context = html.slice(contextStart, contextEnd);
                        
                        if (context.includes('badge-style-type-live-now-alternate')) {
                            confirmedLiveStreams.add(videoId);
                        }
                    }
                    
                    // Extract metadata for confirmed live streams
                    const titlePattern = /"title":"([^"]+)"/g;
                    const channelPattern = /"channelName":"([^"]+)"/g;
                    
                    // Create arrays to match video IDs with their metadata
                    const videoIds = [];
                    const titles = [];
                    const channels = [];
                    
                    // Reset patterns for full extraction
                    html.replace(/"videoId":"([a-zA-Z0-9_-]{11})"/g, (match, id) => {
                        videoIds.push(id);
                        return match;
                    });
                    
                    html.replace(/"title":"([^"]+)"/g, (match, title) => {
                        titles.push(title);
                        return match;
                    });
                    
                    html.replace(/"channelName":"([^"]+)"/g, (match, channel) => {
                        channels.push(channel);
                        return match;
                    });
                    
                    // Match confirmed live streams with their metadata
                    for (const videoId of confirmedLiveStreams) {
                        if (streams.length >= 50) break; // Limit to 50 streams
                        
                        const videoIndex = videoIds.indexOf(videoId);
                        const title = videoIndex >= 0 && titles[videoIndex] ? titles[videoIndex] : 'Live Stream';
                        const channel = videoIndex >= 0 && channels[videoIndex] ? channels[videoIndex] : 'Unknown Channel';
                        
                        streams.push({
                            network: channel,
                            url: `https://www.youtube.com/watch?v=${videoId}`,
                            category: category || 'live-confirmed',
                            videoId: videoId,
                            title: title,
                            discoveredAt: new Date().toISOString(),
                            liveConfirmed: true
                        });
                    }
                    
                    // Fallback: Look for other live indicators if no badge-confirmed streams found
                    if (streams.length === 0) {
                        console.log('No badge-confirmed live streams found, trying fallback patterns...');
                        
                        // Fallback Pattern 1: Various live indicators
                        const fallbackLivePatterns = [
                            /(?:LIVE|live|Live).*?href="\/watch\?v=([a-zA-Z0-9_-]{11})"/gi,
                            /href="\/watch\?v=([a-zA-Z0-9_-]{11})".*?(?:LIVE|live|Live)/gi,
                            /"isLiveContent":true.*?"videoId":"([a-zA-Z0-9_-]{11})"/gi,
                            /"videoId":"([a-zA-Z0-9_-]{11})".*?"isLiveContent":true/gi,
                            /live-badge.*?href="\/watch\?v=([a-zA-Z0-9_-]{11})"/gi,
                            /"badges":\[.*?"style":"LIVE".*?\].*?"videoId":"([a-zA-Z0-9_-]{11})"/gi
                        ];
                        
                        for (const pattern of fallbackLivePatterns) {
                            let fallbackMatch;
                            while ((fallbackMatch = pattern.exec(html)) !== null && streams.length < 50) {
                                const videoId = fallbackMatch[1];
                                if (!streams.find(s => s.videoId === videoId)) {
                                    const title = this.extractTitleForVideo(html, videoId) || 'Live Stream';
                                    const channel = this.extractChannelForVideo(html, videoId) || 'Unknown Channel';
                                    
                                    streams.push({
                                        network: channel,
                                        url: `https://www.youtube.com/watch?v=${videoId}`,
                                        category: category || 'fallback-live',
                                        videoId: videoId,
                                        title: title,
                                        discoveredAt: new Date().toISOString(),
                                        liveConfirmed: false,
                                        detectionMethod: 'fallback-pattern'
                                    });
                                }
                            }
                        }
                    }
                    
                } catch (error) {
                    console.error('Error extracting streams from HTML:', error);
                }
                
                console.log(`Found ${streams.length} live streams total (${streams.filter(s => s.liveConfirmed).length} badge-confirmed, ${streams.filter(s => !s.liveConfirmed).length} fallback)`);
                return streams.slice(0, 50); // Ensure we never return more than 50 streams
            }

            isLikelyLiveStream(title, html, videoId) {
                const liveKeywords = [
                    'live', 'breaking', 'news', 'now', 'stream', 'coverage', 
                    'today', 'current', 'update', 'report', 'broadcast'
                ];
                
                const titleLower = title.toLowerCase();
                const hasLiveKeyword = liveKeywords.some(keyword => titleLower.includes(keyword));
                
                // Check if the video is marked as live in the HTML
                const isMarkedLive = html.includes(`"${videoId}"`) && 
                                   (html.includes('"isLiveContent":true') || 
                                    html.includes('LIVE') || 
                                    html.includes('live'));
                
                return hasLiveKeyword || isMarkedLive;
            }

            showStatus(message, type = 'info') {
                const statusElement = document.getElementById('statusMessage');
                statusElement.className = `p-4 rounded-lg mb-6 ${this.getStatusClasses(type)}`;
                statusElement.textContent = message;
                statusElement.classList.remove('hidden');
                
                setTimeout(() => {
                    statusElement.classList.add('hidden');
                }, 5000);
            }

            getStatusClasses(type) {
                switch (type) {
                    case 'success': return 'bg-green-800 border border-green-600 text-green-100';
                    case 'error': return 'bg-red-800 border border-red-600 text-red-100';
                    case 'warning': return 'bg-yellow-800 border border-yellow-600 text-yellow-100';
                    default: return 'bg-blue-800 border border-blue-600 text-blue-100';
                }
            }

            toggleScanning(scanning) {
                this.isScanning = scanning;
                const button = document.getElementById('scanButton');
                const text = document.getElementById('scanButtonText');
                const loader = document.getElementById('scanLoader');
                
                if (scanning) {
                    button.disabled = true;
                    text.textContent = 'Scanning...';
                    loader.classList.remove('hidden');
                } else {
                    button.disabled = false;
                    text.textContent = 'Scan News Feeds';
                    loader.classList.add('hidden');
                }
            }

            async scanFeeds() {
                if (this.isScanning) return;

                this.toggleScanning(true);
                
                try {
                    // Get streams to scan (now async for dynamic discovery)
                    const streams = await this.getStreamsToScan();
                    
                    if (!streams || streams.length === 0) {
                        this.showStatus('No streams found to scan', 'warning');
                        return;
                    }
                    
                    this.showStatus(`Starting to scan ${streams.length} discovered streams for metadata...`, 'info');

                    const feeds = [];
                    const batchSize = 3; // Process in batches to avoid overwhelming
                    
                    // Update progress to show metadata scanning phase
                    const progressContainer = document.getElementById('scanProgress');
                    const currentScanUrl = document.getElementById('currentScanUrl');
                    const foundStreams = document.getElementById('foundStreams');
                    
                    // Add a separator to show we're now scanning for metadata
                    const separatorDiv = document.createElement('div');
                    separatorDiv.className = 'text-xs text-yellow-400 py-2 border-t border-gray-600 mt-2';
                    separatorDiv.textContent = '--- Now scanning found streams for metadata ---';
                    foundStreams.appendChild(separatorDiv);
                    
                    for (let i = 0; i < streams.length; i += batchSize) {
                        const batch = streams.slice(i, i + batchSize);
                        
                        // Show what we're currently scanning
                        currentScanUrl.textContent = `Scanning metadata for streams ${i + 1}-${Math.min(i + batchSize, streams.length)} of ${streams.length}`;
                        
                        const batchPromises = batch.map(async (stream) => {
                            // Show which stream we're currently scanning
                            const scanningDiv = document.createElement('div');
                            scanningDiv.className = 'text-xs text-blue-400 py-1';
                            scanningDiv.innerHTML = `
                                <span class="text-gray-400">Scanning metadata:</span> 
                                <span class="text-blue-400">${stream.url}</span>
                            `;
                            foundStreams.appendChild(scanningDiv);
                            foundStreams.scrollTop = foundStreams.scrollHeight;
                            
                            const result = await this.scanSingleStream(stream);
                            
                            // Update the scanning div to show completion
                            if (result) {
                                scanningDiv.innerHTML = `
                                    <span class="text-green-400">‚úì Completed:</span> 
                                    <span class="text-blue-400">${stream.url}</span>
                                    <span class="text-gray-300">(${result.viewCountText})</span>
                                `;
                            } else {
                                scanningDiv.innerHTML = `
                                    <span class="text-red-400">‚úó Failed:</span> 
                                    <span class="text-blue-400">${stream.url}</span>
                                `;
                            }
                            foundStreams.scrollTop = foundStreams.scrollHeight;
                            
                            return result;
                        });
                        
                        const batchResults = await Promise.allSettled(batchPromises);
                        
                        batchResults.forEach((result, index) => {
                            if (result.status === 'fulfilled' && result.value) {
                                feeds.push(result.value);
                            } else {
                                console.warn(`Failed to scan ${batch[index].network}:`, result.reason);
                            }
                        });

                        // Update progress
                        this.showStatus(`Scanned ${Math.min(i + batchSize, streams.length)} of ${streams.length} streams...`, 'info');
                        
                        // Small delay between batches
                        if (i + batchSize < streams.length) {
                            await new Promise(resolve => setTimeout(resolve, 500));
                        }
                    }

                    this.feeds = feeds;
                    this.renderResults();
                    
                    // Hide progress container after completion
                    setTimeout(() => {
                        progressContainer.classList.add('hidden');
                    }, 3000);
                    
                    if (feeds.length > 0) {
                        this.showStatus(`Successfully scanned ${feeds.length} live streams (${streams.length - feeds.length} offline)`, 'success');
                    } else {
                        this.showStatus('No live streams found', 'warning');
                    }
                } catch (error) {
                    console.error('Scanning error:', error);
                    this.showStatus(`Error scanning feeds: ${error.message}`, 'error');
                } finally {
                    this.toggleScanning(false);
                    // Hide progress container on error
                    setTimeout(() => {
                        document.getElementById('scanProgress').classList.add('hidden');
                    }, 3000);
                }
            }

            async scanSingleStream(stream) {
                console.log(`Scanning stream: ${stream.title} (${stream.videoId})`);
                
                try {
                    // Extract video ID from URL
                    const videoId = this.extractVideoId(stream.url);
                    if (!videoId) {
                        console.error(`Invalid video URL: ${stream.url}`);
                        throw new Error('Invalid video URL');
                    }

                    console.log(`Extracted video ID: ${videoId}`);

                    // Use YouTube oEmbed API to get basic info
                    const oembedUrl = `https://www.youtube.com/oembed?url=${encodeURIComponent(stream.url)}&format=json`;
                    console.log(`Trying oEmbed: ${oembedUrl}`);
                    
                    try {
                        const response = await fetch(oembedUrl);
                        console.log(`oEmbed response status: ${response.status}`);
                        
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }
                        
                        const data = await response.json();
                        console.log(`oEmbed data:`, data);
                        
                        // Get comprehensive metadata
                        const viewerData = await this.getViewerData(videoId);
                        const extendedMetadata = await this.getExtendedMetadata(videoId);
                        
                        const result = {
                            network: stream.network || data.author_name || 'Unknown Channel',
                            title: data.title || stream.title || 'Live Stream',
                            url: stream.url,
                            videoId: videoId,
                            thumbnailUrl: data.thumbnail_url || '',
                            authorName: data.author_name || stream.network || 'Unknown',
                            authorUrl: data.author_url || '',
                            width: data.width || 'Unknown',
                            height: data.height || 'Unknown',
                            resolution: data.width && data.height ? `${data.width}x${data.height}` : 'Unknown',
                            viewCount: viewerData.viewCount || 0,
                            viewCountText: viewerData.viewCountText || 'Unknown',
                            duration: 'Live',
                            isLive: true,
                            liveStatus: extendedMetadata.liveStatus || 'Live',
                            status: 'live',
                            category: stream.category || 'discovered',
                            // Extended metadata
                            subscriberCount: extendedMetadata.subscriberCount || 'Unknown',
                            publishedAt: extendedMetadata.publishedAt || 'Unknown',
                            publishedRelative: extendedMetadata.publishedRelative || 'Unknown',
                            tags: extendedMetadata.tags || [],
                            description: extendedMetadata.description || '',
                            language: extendedMetadata.language || 'Unknown',
                            region: extendedMetadata.region || 'Unknown',
                            chatEnabled: extendedMetadata.chatEnabled || false,
                            allowRatings: extendedMetadata.allowRatings !== false,
                            ageRestricted: extendedMetadata.ageRestricted || false,
                            familyFriendly: extendedMetadata.familyFriendly !== false,
                            quality: this.extractQualityFromTitle(data.title || '').quality || 'Unknown',
                            fps: this.extractQualityFromTitle(data.title || '').fps || 'Unknown',
                            scannedAt: new Date().toISOString(),
                            discoveredAt: stream.discoveredAt || new Date().toISOString(),
                            discoveryMethod: 'youtube-search',
                            liveConfirmed: stream.liveConfirmed || false,
                            detectionMethod: stream.detectionMethod || 'youtube-extraction'
                        };
                        
                        console.log(`Successfully processed stream: ${result.title}`);
                        return result;
                        
                    } catch (oembedError) {
                        console.warn(`oEmbed failed for ${videoId}:`, oembedError);
                        
                        // Fallback: create basic entry with discovered metadata
                        const basicMetadata = await this.getBasicStreamMetadata(videoId);
                        const viewerData = await this.getViewerData(videoId);
                        
                        const fallbackResult = {
                            network: stream.network || 'Unknown Channel',
                            title: stream.title || 'Live Stream',
                            url: stream.url,
                            videoId: videoId,
                            thumbnailUrl: basicMetadata.thumbnail || '',
                            authorName: stream.network || 'Unknown',
                            authorUrl: '',
                            width: 'Unknown',
                            height: 'Unknown',
                            resolution: 'Unknown',
                            viewCount: viewerData.viewCount || 0,
                            viewCountText: viewerData.viewCountText || 'Unknown',
                            duration: 'Live',
                            isLive: true,
                            liveStatus: 'Sample Live',
                            status: 'live',
                            category: stream.category || 'discovered',
                            subscriberCount: 'Unknown',
                            publishedAt: 'Unknown',
                            publishedRelative: 'Unknown',
                            tags: [],
                            description: '',
                            language: 'Unknown',
                            region: 'Unknown',
                            chatEnabled: false,
                            allowRatings: true,
                            ageRestricted: false,
                            familyFriendly: true,
                            quality: 'Unknown',
                            fps: 'Unknown',
                            scannedAt: new Date().toISOString(),
                            discoveredAt: stream.discoveredAt || new Date().toISOString(),
                            discoveryMethod: 'youtube-search-fallback',
                            liveConfirmed: stream.liveConfirmed || false,
                            detectionMethod: stream.detectionMethod || 'youtube-extraction'
                        };
                        
                        console.log(`Using fallback data for: ${fallbackResult.title}`);
                        return fallbackResult;
                    }
                } catch (error) {
                    console.error(`Error scanning ${stream.network || 'Unknown'}:`, error);
                    return null;
                }
            }

            async getExtendedMetadata(videoId) {
                try {
                    // Cannot fetch YouTube pages directly due to CORS
                    // Return default metadata for now
                    console.log(`Would fetch metadata for video: ${videoId}`);
                    return this.getDefaultMetadata();
                } catch (error) {
                    return this.getDefaultMetadata();
                }
            }

            async getBasicStreamMetadata(videoId) {
                return {
                    thumbnail: `https://img.youtube.com/vi/${videoId}/maxresdefault.jpg`
                };
            }

            getDefaultMetadata() {
                return {
                    subscriberCount: 'Unknown',
                    publishedAt: 'Unknown',
                    publishedRelative: 'Unknown',
                    liveStatus: 'Live',
                    tags: [],
                    description: '',
                    language: 'Unknown',
                    region: 'Unknown',
                    chatEnabled: false,
                    allowRatings: true,
                    ageRestricted: false,
                    familyFriendly: true
                };
            }

            extractQualityFromTitle(title) {
                const qualityPattern = /(\d{3,4}p)|(\d+fps)|(\d+k)/gi;
                const matches = title.match(qualityPattern) || [];
                
                let quality = 'Unknown';
                let fps = 'Unknown';
                
                matches.forEach(match => {
                    if (match.includes('p')) {
                        quality = match.toUpperCase();
                    } else if (match.includes('fps')) {
                        fps = match;
                    } else if (match.includes('k') || match.includes('K')) {
                        quality = match.toUpperCase();
                    }
                });
                
                return { quality, fps };
            }

            // Metadata extraction helper methods
            extractSubscriberCount(html) {
                const patterns = [
                    /"subscriberCountText":"([^"]+)"/,
                    /(\d+(?:\.\d+)?[KMB]?) subscriber/i
                ];
                
                for (const pattern of patterns) {
                    const match = html.match(pattern);
                    if (match) return match[1];
                }
                return 'Unknown';
            }

            extractPublishedDate(html) {
                const patterns = [
                    /"publishDate":"([^"]+)"/,
                    /"uploadDate":"([^"]+)"/
                ];
                
                for (const pattern of patterns) {
                    const match = html.match(pattern);
                    if (match) {
                        try {
                            return new Date(match[1]).toLocaleDateString();
                        } catch {
                            return match[1];
                        }
                    }
                }
                return 'Unknown';
            }

            extractPublishedRelative(html) {
                const patterns = [
                    /Started streaming (\d+ \w+ ago)/i,
                    /Streamed (\d+ \w+ ago)/i
                ];
                
                for (const pattern of patterns) {
                    const match = html.match(pattern);
                    if (match) return match[1];
                }
                return 'Unknown';
            }

            extractLiveStatus(html) {
                if (html.includes('"isLiveContent":true')) return 'Live';
                if (html.includes('LIVE')) return 'Live';
                if (html.includes('Premiere')) return 'Premiere';
                return 'Live';
            }

            extractTags(html) {
                try {
                    const tagPattern = /"keywords":\[([^\]]+)\]/;
                    const match = html.match(tagPattern);
                    if (match) {
                        const tagsJson = match[1];
                        const tags = JSON.parse(`[${tagsJson}]`);
                        return tags.slice(0, 10);
                    }
                } catch (error) {
                    const altPattern = /"tag":"([^"]+)"/g;
                    const tags = [];
                    let match;
                    while ((match = altPattern.exec(html)) !== null && tags.length < 10) {
                        tags.push(match[1]);
                    }
                    return tags;
                }
                return [];
            }

            extractDescription(html) {
                try {
                    const patterns = [
                        /"shortDescription":"([^"]+)"/,
                        /"description":"([^"]+)"/
                    ];
                    
                    for (const pattern of patterns) {
                        const match = html.match(pattern);
                        if (match) {
                            return match[1].replace(/\\n/g, ' ').substring(0, 200);
                        }
                    }
                } catch (error) {
                    console.error('Error extracting description:', error);
                }
                return '';
            }

            extractLanguage(html) {
                const patterns = [
                    /"defaultAudioLanguage":"([^"]+)"/,
                    /"inLanguage":"([^"]+)"/
                ];
                
                for (const pattern of patterns) {
                    const match = html.match(pattern);
                    if (match) return match[1];
                }
                return 'Unknown';
            }

            extractRegion(html) {
                const patterns = [
                    /"regionsAllowed":\["([^"]+)"/,
                    /"country":"([^"]+)"/
                ];
                
                for (const pattern of patterns) {
                    const match = html.match(pattern);
                    if (match) return match[1];
                }
                return 'Unknown';
            }

            extractChatEnabled(html) {
                return html.includes('"isChatEnabled":true') || html.includes('live chat');
            }

            extractAllowRatings(html) {
                return !html.includes('"allowRatings":false');
            }

            extractAgeRestricted(html) {
                return html.includes('"isContentRatingRequired":true') || html.includes('age-restricted');
            }

            extractFamilyFriendly(html) {
                return !this.extractAgeRestricted(html);
            }

            extractVideoId(url) {
                const patterns = [
                    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/
                ];

                for (const pattern of patterns) {
                    const match = url.match(pattern);
                    if (match) return match[1];
                }
                return null;
            }

            async getViewerData(videoId) {
                try {
                    // Cannot fetch YouTube pages directly due to CORS
                    // Return placeholder data since we can't access real viewer counts
                    console.log(`Cannot fetch viewer data for video: ${videoId} due to CORS`);
                    return {
                        viewCount: 0,
                        viewCountText: 'Unknown viewers'
                    };
                } catch (error) {
                    return { viewCount: 0, viewCountText: 'Unknown' };
                }
            }

            formatViewCount(count) {
                if (count >= 1000000) {
                    return (count / 1000000).toFixed(1) + 'M viewers';
                } else if (count >= 1000) {
                    return (count / 1000).toFixed(1) + 'K viewers';
                } else {
                    return count + ' viewers';
                }
            }

            renderResults() {
                const container = document.getElementById('resultsContainer');
                const tbody = document.getElementById('feedsTableBody');
                const feedCount = document.getElementById('feedCount');
                const exportButton = document.getElementById('exportButton');
                const copyUrlsButton = document.getElementById('copyUrlsButton');
                
                tbody.innerHTML = '';
                
                if (this.feeds.length === 0) {
                    container.classList.add('hidden');
                    exportButton.disabled = true;
                    copyUrlsButton.disabled = true;
                    return;
                }
                
                container.classList.remove('hidden');
                exportButton.disabled = false;
                copyUrlsButton.disabled = false;
                feedCount.textContent = `${this.feeds.length} stream${this.feeds.length !== 1 ? 's' : ''}`;
                
                // Sort feeds by network name
                this.feeds.sort((a, b) => a.network.localeCompare(b.network));
                
                this.feeds.forEach((feed, index) => {
                    const row = this.createFeedRow(feed, index);
                    tbody.appendChild(row);
                });
            }

            createFeedRow(feed, index) {
                const row = document.createElement('tr');
                row.className = 'feed-row border-b border-gray-700 hover:bg-gray-700 transition-colors';
                
                const includeDuration = document.getElementById('includeDuration').checked;
                
                // Helper function to safely escape HTML
                const escapeHtml = (text) => {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                };
                
                row.innerHTML = `
                    <td class="py-3 px-2">
                        <span class="status-indicator ${this.getStatusClass(feed.status)}"></span>
                        <span class="text-sm capitalize text-red-400 font-medium">${feed.liveStatus || 'LIVE'}</span>
                        ${feed.liveConfirmed ? '<div class="text-xs text-green-400">‚úì Badge Confirmed</div>' : '<div class="text-xs text-yellow-400">‚ö† Fallback Detection</div>'}
                    </td>
                    <td class="py-3 px-2">
                        <div class="font-medium text-blue-400">${escapeHtml(feed.network)}</div>
                        <div class="text-xs text-gray-400">${escapeHtml(feed.category)}</div>
                    </td>
                    <td class="py-3 px-2">
                        <div class="max-w-xs">
                            <div class="font-medium truncate" title="${escapeHtml(feed.title)}">${escapeHtml(feed.title)}</div>
                            <div class="text-xs text-gray-400">ID: ${feed.videoId}</div>
                            ${feed.resolution !== 'Unknown' ? `<div class="text-xs text-gray-500">${feed.resolution}</div>` : ''}
                        </div>
                    </td>
                    <td class="py-3 px-2">
                        <div class="max-w-xs">
                            <div class="font-medium text-green-400">${escapeHtml(feed.authorName)}</div>
                            ${feed.subscriberCount !== 'Unknown' ? `<div class="text-xs text-gray-400">${feed.subscriberCount} subscribers</div>` : ''}
                        </div>
                    </td>
                    <td class="py-3 px-2">
                        ${includeDuration ? `
                            <span class="text-sm text-green-400">${feed.duration}</span>
                            ${feed.publishedRelative !== 'Unknown' ? `<div class="text-xs text-gray-400">${escapeHtml(feed.publishedRelative)}</div>` : ''}
                        ` : '<span class="text-gray-500">Hidden</span>'}
                    </td>
                    <td class="py-3 px-2">
                        <div class="max-w-xs">
                            <div class="text-sm ${feed.liveConfirmed ? 'text-green-400' : feed.discoveryMethod === 'dynamic' ? 'text-yellow-400' : 'text-orange-400'}">
                                ${feed.liveConfirmed ? 'üî¥ Live Badge' : feed.discoveryMethod === 'dynamic' ? 'üü° Dynamic' : 'üü† Static'}
                            </div>
                            <div class="text-xs text-gray-400">
                                ${feed.liveConfirmed ? 'badge-style-type-live-now-alternate' : feed.detectionMethod || 'standard'}
                            </div>
                            <div class="text-xs text-gray-400">Scanned: ${new Date(feed.scannedAt).toLocaleTimeString()}</div>
                            ${feed.discoveredAt ? `<div class="text-xs text-gray-500">Found: ${new Date(feed.discoveredAt).toLocaleTimeString()}</div>` : ''}
                        </div>
                    </td>
                    <td class="py-3 px-2">
                        <div class="flex gap-2">
                            <button 
                                onclick="window.open('${feed.url}', '_blank')" 
                                class="text-blue-400 hover:text-blue-300 text-sm font-medium"
                                title="Open video"
                            >
                                Watch
                            </button>
                            <button 
                                onclick="navigator.clipboard.writeText('${feed.url}').then(() => this.textContent = 'Copied!').then(() => setTimeout(() => this.textContent = 'Copy', 1000))" 
                                class="copy-button text-gray-400 hover:text-gray-300 text-sm font-medium"
                                title="Copy URL"
                            >
                                Copy
                            </button>
                            <button 
                                onclick="window.newsScanner.showMetadataModal(${index})" 
                                class="text-gray-400 hover:text-blue-400 text-sm font-medium"
                                title="View full metadata"
                            >
                                Details
                            </button>
                        </div>
                    </td>
                `;
                
                return row;
            }

            getStatusClass(status) {
                return 'status-live';
            }

            clearResults() {
                this.feeds = [];
                document.getElementById('resultsContainer').classList.add('hidden');
                document.getElementById('exportButton').disabled = true;
                document.getElementById('copyUrlsButton').disabled = true;
                // Hide progress container
                document.getElementById('scanProgress').classList.add('hidden');
                this.showStatus('Results cleared', 'info');
            }

            exportResults() {
                if (this.feeds.length === 0) {
                    this.showStatus('No feeds to export', 'warning');
                    return;
                }

                // Create CSV content
                const headers = ['Network', 'Title', 'Category', 'Viewers', 'ViewerText', 'Duration', 'URL', 'VideoID', 'ScannedAt'];
                const csvContent = [
                    headers.join(','),
                    ...this.feeds.map(feed => [
                        `"${feed.network}"`,
                        `"${feed.title.replace(/"/g, '""')}"`,
                        `"${feed.category}"`,
                        feed.viewCount,
                        `"${feed.viewCountText}"`,
                        `"${feed.duration}"`,
                        `"${feed.url}"`,
                        `"${feed.videoId}"`,
                        `"${feed.scannedAt}"`
                    ].join(','))
                ].join('\n');

                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                
                link.setAttribute('href', url);
                link.setAttribute('download', `news-streams-${new Date().toISOString().split('T')[0]}.csv`);
                link.style.visibility = 'hidden';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                URL.revokeObjectURL(url);
                
                this.showStatus('CSV exported successfully', 'success');
            }

            async copyUrls() {
                if (this.feeds.length === 0) {
                    this.showStatus('No URLs to copy', 'warning');
                    return;
                }

                const urls = this.feeds.map(feed => feed.url).join('\n');
                
                try {
                    await navigator.clipboard.writeText(urls);
                    this.showStatus(`Copied ${this.feeds.length} URL${this.feeds.length === 1 ? '' : 's'} to clipboard`, 'success');
                } catch (error) {
                    this.showStatus('Failed to copy URLs to clipboard', 'error');
                }
            }

            showMetadataModal(feedIndex) {
                const feed = this.feeds[feedIndex];
                if (!feed) return;

                // Create modal if it doesn't exist
                let modal = document.getElementById('metadataModal');
                if (!modal) {
                    modal = this.createMetadataModal();
                    document.body.appendChild(modal);
                }

                // Populate modal with feed data
                this.populateMetadataModal(feed);
                modal.classList.remove('hidden');
            }

            createMetadataModal() {
                const modal = document.createElement('div');
                modal.id = 'metadataModal';
                modal.className = 'fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-50 hidden';
                
                modal.innerHTML = `
                    <div class="bg-gray-800 rounded-lg shadow-2xl p-6 w-full max-w-4xl max-h-[90vh] overflow-auto">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-xl font-bold text-white">Stream Metadata Details</h3>
                            <button onclick="document.getElementById('metadataModal').classList.add('hidden')" class="text-gray-400 hover:text-white text-2xl">&times;</button>
                        </div>
                        <div id="metadataContent" class="space-y-4">
                            <!-- Content will be populated dynamically -->
                        </div>
                        <div class="mt-6 flex gap-3">
                            <button onclick="window.open(document.getElementById('metadataModal').dataset.url, '_blank')" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">
                                Open Stream
                            </button>
                            <button onclick="navigator.clipboard.writeText(document.getElementById('metadataModal').dataset.url)" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">
                                Copy URL
                            </button>
                            <button onclick="document.getElementById('metadataModal').classList.add('hidden')" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">
                                Close
                            </button>
                        </div>
                    </div>
                `;

                // Close modal when clicking outside
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.classList.add('hidden');
                    }
                });

                return modal;
            }

            populateMetadataModal(feed) {
                const modal = document.getElementById('metadataModal');
                const content = document.getElementById('metadataContent');
                modal.dataset.url = feed.url;

                const escapeHtml = (text) => {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                };

                content.innerHTML = `
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <!-- Basic Info -->
                        <div class="space-y-3">
                            <h4 class="text-lg font-semibold text-blue-400">Basic Information</h4>
                            <div class="space-y-2 text-sm">
                                <div><span class="text-gray-400">Network:</span> <span class="text-white">${escapeHtml(feed.network)}</span></div>
                                <div><span class="text-gray-400">Title:</span> <span class="text-white">${escapeHtml(feed.title)}</span></div>
                                <div><span class="text-gray-400">Channel:</span> <span class="text-white">${escapeHtml(feed.authorName)}</span></div>
                                <div><span class="text-gray-400">Video ID:</span> <span class="font-mono text-green-400">${feed.videoId}</span></div>
                                <div><span class="text-gray-400">Category:</span> <span class="text-white">${escapeHtml(feed.category)}</span></div>
                                <div><span class="text-gray-400">Status:</span> <span class="text-red-400">${feed.liveStatus}</span></div>
                            </div>
                        </div>

                        <!-- Technical Details -->
                        <div class="space-y-3">
                            <h4 class="text-lg font-semibold text-purple-400">Technical Details</h4>
                            <div class="space-y-2 text-sm">
                                <div><span class="text-gray-400">Resolution:</span> <span class="text-white">${feed.resolution}</span></div>
                                <div><span class="text-gray-400">Quality:</span> <span class="text-white">${feed.quality}</span></div>
                                <div><span class="text-gray-400">FPS:</span> <span class="text-white">${feed.fps}</span></div>
                                <div><span class="text-gray-400">Language:</span> <span class="text-white">${feed.language}</span></div>
                                <div><span class="text-gray-400">Region:</span> <span class="text-white">${feed.region}</span></div>
                            </div>
                        </div>

                        <!-- Engagement -->
                        <div class="space-y-3">
                            <h4 class="text-lg font-semibold text-green-400">Engagement</h4>
                            <div class="space-y-2 text-sm">
                                <div><span class="text-gray-400">Current Viewers:</span> <span class="text-white">${feed.viewCount.toLocaleString()}</span></div>
                                <div><span class="text-gray-400">Viewer Text:</span> <span class="text-white">${escapeHtml(feed.viewCountText)}</span></div>
                                <div><span class="text-gray-400">Subscribers:</span> <span class="text-white">${feed.subscriberCount}</span></div>
                                <div><span class="text-gray-400">Chat Enabled:</span> <span class="${feed.chatEnabled ? 'text-green-400' : 'text-red-400'}">${feed.chatEnabled ? 'Yes' : 'No'}</span></div>
                                <div><span class="text-gray-400">Ratings Allowed:</span> <span class="${feed.allowRatings ? 'text-green-400' : 'text-red-400'}">${feed.allowRatings ? 'Yes' : 'No'}</span></div>
                            </div>
                        </div>

                        <!-- Discovery Info -->
                        <div class="space-y-3">
                            <h4 class="text-lg font-semibold text-yellow-400">Discovery Information</h4>
                            <div class="space-y-2 text-sm">
                                <div><span class="text-gray-400">Discovery Method:</span> <span class="text-white">${feed.discoveryMethod || 'static'}</span></div>
                                <div><span class="text-gray-400">Discovered At:</span> <span class="text-white">${feed.discoveredAt ? new Date(feed.discoveredAt).toLocaleString() : 'N/A'}</span></div>
                                <div><span class="text-gray-400">Scanned At:</span> <span class="text-white">${new Date(feed.scannedAt).toLocaleString()}</span></div>
                                <div><span class="text-gray-400">Family Friendly:</span> <span class="${feed.familyFriendly ? 'text-green-400' : 'text-yellow-400'}">${feed.familyFriendly ? 'Yes' : 'No'}</span></div>
                                <div><span class="text-gray-400">Age Restricted:</span> <span class="${feed.ageRestricted ? 'text-red-400' : 'text-green-400'}">${feed.ageRestricted ? 'Yes' : 'No'}</span></div>
                            </div>
                        </div>
                    </div>

                    ${feed.tags && feed.tags.length > 0 ? `
                        <div class="mt-6">
                            <h4 class="text-lg font-semibold text-pink-400 mb-2">Tags</h4>
                            <div class="flex flex-wrap gap-2">
                                ${feed.tags.map(tag => `<span class="bg-gray-700 text-gray-300 px-2 py-1 rounded text-xs">${escapeHtml(tag)}</span>`).join('')}
                            </div>
                        </div>
                    ` : ''}

                    ${feed.description ? `
                        <div class="mt-6">
                            <h4 class="text-lg font-semibold text-cyan-400 mb-2">Description</h4>
                            <div class="bg-gray-700 p-3 rounded text-sm text-gray-300 max-h-32 overflow-y-auto">
                                ${escapeHtml(feed.description)}
                            </div>
                        </div>
                    ` : ''}
                `;
            }

            extractTitleForVideo(html, videoId) {
                try {
                    // Look for the title associated with this video ID
                    const videoIdIndex = html.indexOf(`"videoId":"${videoId}"`);
                    if (videoIdIndex === -1) return null;
                    
                    // Search for title pattern within reasonable distance
                    const searchStart = Math.max(0, videoIdIndex - 2000);
                    const searchEnd = Math.min(html.length, videoIdIndex + 2000);
                    const searchRegion = html.slice(searchStart, searchEnd);
                    
                    const titlePatterns = [
                        /"title":"([^"]+)"/,
                        /"text":"([^"]+)"/
                    ];
                    
                    for (const pattern of titlePatterns) {
                        const match = searchRegion.match(pattern);
                        if (match && match[1] && match[1].length > 5) {
                            return match[1];
                        }
                    }
                    
                    return null;
                } catch (error) {
                    console.error('Error extracting title for video:', error);
                    return null;
                }
            }

            extractChannelForVideo(html, videoId) {
                try {
                    // Look for the channel name associated with this video ID
                    const videoIdIndex = html.indexOf(`"videoId":"${videoId}"`);
                    if (videoIdIndex === -1) return null;
                    
                    // Search for channel pattern within reasonable distance
                    const searchStart = Math.max(0, videoIdIndex - 2000);
                    const searchEnd = Math.min(html.length, videoIdIndex + 2000);
                    const searchRegion = html.slice(searchStart, searchEnd);
                    
                    const channelPatterns = [
                        /"channelName":"([^"]+)"/,
                        /"ownerChannelName":"([^"]+)"/,
                        /"author":"([^"]+)"/
                    ];
                    
                    for (const pattern of channelPatterns) {
                        const match = searchRegion.match(pattern);
                        if (match && match[1] && match[1].length > 1) {
                            return match[1];
                        }
                    }
                    
                    return null;
                } catch (error) {
                    console.error('Error extracting channel for video:', error);
                    return null;
                }
            }

            // ...existing code...
        }

        // Initialize the scanner when the page loads
        let newsScanner;
        document.addEventListener('DOMContentLoaded', () => {
            newsScanner = new NewsStreamScanner();
            window.newsScanner = newsScanner; // Make globally accessible
        });
    </script>

    <!-- Footer -->
    <footer class="text-center py-6 mt-12 border-t border-gray-600">
        <p class="text-gray-400 text-sm">
            Part of <a href="index.html" class="text-blue-400 hover:text-blue-300">MultiStreamNews.TV</a> ‚Ä¢ 
            Last Updated: <span class="text-gray-300">December 30, 2024 at 22:45 UTC - Dynamic Discovery System</span>
        </p>
    </footer>
</body>
</html>
